/*                                    tab:8
 *
 * maze.c - maze generation and display functions
 *
 * "Copyright (c) 2004-2009 by Steven S. Lumetta."
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice and the following
 * two paragraphs appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE AUTHOR OR THE UNIVERSITY OF ILLINOIS BE LIABLE TO
 * ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
 * DAMAGES ARISING OUT  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
 * EVEN IF THE AUTHOR AND/OR THE UNIVERSITY OF ILLINOIS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR AND THE UNIVERSITY OF ILLINOIS SPECIFICALLY DISCLAIM ANY
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE
 * PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND NEITHER THE AUTHOR NOR
 * THE UNIVERSITY OF ILLINOIS HAS ANY OBLIGATION TO PROVIDE MAINTENANCE,
 * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
 *
 * Author:        Steve Lumetta
 * Version:        3
 * Creation Date:   Fri Sep 10 09:58:42 2004
 * Filename:        maze.c
 * History:
 *    SL    1    Fri Sep 10 09:58:42 2004
 *        First written.
 *    SL    2    Sat Sep 12 14:17:45 2009
 *        Integrated original release back into main code base.
 *    SL    3    Sat Sep 12 18:41:31 2009
 *        Integrated Nate Taylor's "god mode."
 */

#include "blocks.h"
#include "input.h"
#include "maze.h"
#include "modex.h"
#include "ece391support.h"

uint32_t random_numbers[] = {423538819,438122450,684742677,943459824,940164534,464420005,910787153,108298006,251858317,320227626,437184388,556899861,891201832,159728710,869530467,383637291,674294557,867571372,632754124,794598111,868277951,448481285,761660621,336353337,293267609,300686265,401007075,506340036,427847277,890276559,758856086,979136853,578358708,101778669,493989869,853945621,791164495,546184653,135106704,50715903,498001801,572883002,969358408,387347905,89278671,873923708,102288709,977204932,884052490,906717493,536778854,23685196,646236808,880157334,209753537,56577626,996917953,3202275,368213507,897210301,658397585,114718676,490779807,206255944,606741351,839292099,354875393,72038575,386461925,225150843,922066599,173663254,31268565,764067511,441196710,190563884,519766692,552317702,862555447,881029209,376087479,687273473,808422777,91420205,877086025,123584731,244726995,387143556,537945095,878043659,271643849,752147858,310784064,364089990,440521582,721939247,567870602,137030338,679330399,172104077,89464807,354223172,108751421,166077731,594164919,860833655,994764631,318188660,294710962,199320596,889755401,225218293,469293218,266873986,70109063,80221962,860270372,992998570,901663842,159351857,474101505,427053539,32236489,790749776,46766474,22509735,573021952,367387439,961175126,557406761,598169144,461482002,664092105,276968550,921800780,798187953,144694799,539759366,885864469,444246115,458241610,333934606,783350942,478149,433050821,72272962,852320170,519034581,659498042,604866772,240874916,901126165,608362613,841519186,435488915,450804542,146132585,715665312,599302757,80210813,667928882,630441219,396119021,124847987,162267864,615894756,271644088,895386226,911612442,560113054,621115586,704792886,680711440,863783991,832265807,977959745,177263567,25674244,487233734,905146994,632917038,361585918,599471046,138242553,584753519,398167218,31851851,157823095,767069529,792770271,218855245,742882581,514881957,857447365,314497993,280960783,508897723,956222256,718538277,483078742,522853397,500474754,254572369,212573271,257376996,817126375,280960761,84532086,847444145,408920494,358119235,534629031,735334934,470841599,44838733,30776191,646556832,692049534,449361261,504571915,733449336,552652056,334889402,887788984,718586785,296362749,680255132,788312300,911039423,268530171,133051879,105531025,806861605,643704890,312273409,759836422,65725504,708024156,174925231,945361191,97402066,767385151,235292596,85500055,194780191,392567649,654047308,508689479,569508202,979910027,786753624,910878472,34178844,258395908,834258416,923408538,760532179,84042988,233901020,465371145,872864687,167379443,204374324,720211005,951324409,796334599,203577541,467438638,304447507,751743772,576842622,64753954,694075098,398702955,172652843,127509809,863866478,217072292,592340784,552574411,663721146,59387114,289666949,191570074,285674846,993292270,618480808,210118980,620607159,961701275,825442394,835095883,671092988,628137835,122863416,573582705,871194927,241197691,258259249,314853563,280173048,681172261,335939287,365285224,69582460,911331040,265659155,244334957,796697171,844288342,519371074,447974930,432526987,520011053,550726197,956244013,819682230,466983124,242568746,757403368,168791524,204353416,431538654,46707641,985834552,958110402,224829428,417318478,306140331,325797663,428349329,897061331,315198476,550278826,265771082,370194099,101091601,241659552,192177370,716834284,422901765,835102890,740344746,955810628,995036618,619353814,148170956,681774713,64689637,543526680,673544491,76322764,16155666,278769745,249045921,429411592,660583268,671281611,318739277,946552056,549561475,927741883,720712440,236037365,377171457,122010904,442923936,522244789,394684490,821966603,886573770,577292975,589071822,881135683,596221058,923895795,503954280,278421913,902483010,80717915,724154197,6701958,537149761,248826594,891275474,527582513,478243356,561785365,889018609,227182603,59847723,343226504,834827772,761834301,411886871,808136959,103621585,538781855,360674112,538902813,363685528,278270345,958255157,54245047,866237801,404618772,762777714,708196295,975021445,832142938,955035456,563784265,589859076,323986417,17113069,384884122,975210008,724008807,82428485,789677594,862781374,918856680,693338069,211963445,611819824,916019823,424307435,644693829,406392084,39811873,803108350,57458268,153028500,412432054,740505984,82271677,91146431,986624943,27272080,987675770,530763019,455175590,879605500,656841423,827579403,320953279,288618535,450225606,810938343,803339590,354555778,66725130,699055018,758320009,586047273,68842201,132201944,540499010,322800671,13550625,99725869,994977317,766323809,448091883,236810080,265346693,462567740,254909293,418404672,564327371,385522509,853987002,342968185,276605824,499461156,313503364,34816205,779026761,338616789,74883618,967816767,667158226,725677737,101641150,549458053,969610161,489434057,638618517,978835743,85015680,815419491,821914079,128324674,848186745,137384876,528278207,988001123,465939328,600316767,879070946,466516566,729991318,725262808,919577966,155962148,501669459,904768246,652294475,786128968,385105844,216582774,228581374,711436919,235716554,504018548,636148902,733818411,394751504,822278158,450847794,740177363,900410410,980286762,870916801,552518197,935787429,863817817,845026613,926186792,947928931,70529885,899148767,256690391,683038202,13197598,585010056,304820584,343203373,859667980,574653551,838598115,136586745,358699952,517122387,734701869,928177004,496550860,764890992,221360900,327585995,943875714,300539645,177996678,780952847,269765627,130836147,734611890,97686726,939273281,605820923,154783823,844277061,960384752,378993382,825712160,399766970,441307961,984083464,482612716,174262522,940390920,43030722,356320940,272007360,700758162,55708791,967333383,740919140,572799810,195159762,550111887,549131240,287603216,795172665,506654206,128786893,631936088,848261580,109959090,335937663,871392836,835772566,914937719,42932444,57607587,210842380,426275702,130231187,427710125,806341178,293496624,381982282,931473150,494733052,706154532,557144424,639501090,544682828,549346090,524618751,460315889,489017820,691646467,718141804,622919960,878639761,39095203,723317796,272830540,790137096,5133619,741450542,243060551,124146697,313860749,896192133,219977249,505094609,151785106,607277970,50494222,895975830,783641152,755004001,875616891,270628207,624799244,847210689,816459952,298273759,441989968,67700290,12241904,120982415,945730140,391540266,566677700,277246366,929308219,675857345,93193734,109949134,164099301,348628053,341948503,166907573,933738190,921945074,571492900,416099934,630200821,96325686,964737960,402249189,346414058,559272534,252009308,954761108,199358673,120483175,534255505,828901140,740318442,317191882,900407761,227425496,148116227,336535948,356329326,474211091,439093206,949895484,405035503,765712406,604249767,799581253,85220733,170040403,373780565,593732563,738776540,117067103,579126458,561593436,339331626,942953088,773024786,51567799,200820826,78012601,139727696,885669076,494588237,658948971,624806272,162079207,649491853,14147604,120225392,86460802,687896615,596945015,354005017,925868990,467543732,605914439,624997362,915695255,82966018,109909258,938947166,277843579,110453220,711822559,350081276,15757958,382387083,474957935,689841826,561345075,798305796,131080000,623820887,560059414,81288086,657696308,942777590,855599233,570475295,568820655,675098295,894071738,831945882,17325496,538247073,6377468,794129142,106724102,511320285,88109042,997574613,288421931,860939714,747914921,877421708,647088435,374352074,448567727,67718942,939901715,60619980,428445701,90697415,776862418,80781623,838397682,127737555,116432741,627078587,635988767,790931436,382192980,669650037,408672299,423445079,110280196,700283220,711372177,626751303,796776368,952376495,496633737,804864239,508749510,294981010,239572612,672268887,504872558,745202350,647811379,41354286,86043679,456984306,624603353,37361400,428061234,217773795,274917380,644454825,31920147,202318034,651911971,944724673,400928389,575929272,830382709,575289553,680197012,450211412,435815282,695204030,77759150,239195762,994980204,616976240,494279009,365007433,549355888,864268095,129543219,646516942,326589110,232997588,290650066,256845340,227282838,247765094,370150705,833864053,377928114,985813872,108260437,348324225,316909954,343954321,383979033,574072644,487038160,55019361,337406690,778197654,801727144,169755050,511974444,333982558,364256648,893671490,715992553,896600151,734061473,592778883,96650869,727537924,197092667,963693804,6752986,328507278,793148580,285162984,239146068,926519198,913747423,246683119,302711925,417178432,384912554,381421743,664549563,85907917,26911055,618245178,145445215,976186491,953814102,153389068,517592205,716885205,964341817,619398526,67229251,392401045,681637288,141951953,16275993,293210235,574777375,687242728,599165369,177631776,598961462,218250454,171508462,783663289,926800745,487069423,106327658,144062342,855204072,379222473,166121018,439484198,101744929,73910548,469579682,982917798,592839532,92517816,170591639,577135184,711470154,610676943,706148163,751246245,909684854,375271992,437048768,119142263,153996061,417723642,14131025,358347621,774198859,241387391,579283435,297672335,889433976,616142177,607739757,985361470,512601113,333351951,70864671,286002957,549426253,215774285,305863033,505628709,515334681,456263021,268058603,971618226,690299186,710042388,983090085,288517353,766726594,235217778,706926526,644404345,862233027,887950834,998366025,140732310,870671186,499405987,688464508,989742933,230317725,876392840,106557636,235493693,343976833,647445738,434453375,243339777,791929350,179459703,144323097,743423560,226032703,412227723,184196010,278326767,185177589,394901168,464597415,820928821,572029420,895881748,100510718,348248024,30705970,291630008,358399051,412017873,31289809,617345844,534020669,152705755,724986387,279591331,69550603,285787821,461459347,287794821,75665351,312593718,188705144,460278444,624514454,64497000,653901194,845820239,923803501,155743290,538559856,878214174,27426243,712228785,199277272,54987300,481094762,717432491,42276773,965810830,909263449,987914944,397907585,706306811,69378977,777468296,693952606,622887709,937172914,260058407,230757702,153013223,151431975,708390156,770282993,542434179,222814543,427447338,946812645,961182203,876557623,229861729,565149784,899003824,957490567,338665741,586710315,335623486,670175121,535643347,3656002,54144556,892899774,113151519,493109084,238743096,530340553,411123592,111920373,253135585,832424890,949539253,999437177,535635464,680534691,862762813,339757977,714545699,230553529,141606649,105565812,811105272,599348434,528945397,841099103,276717768,68425035,916035887,242476577,178997075,81796658,609875063,468294268,179245572,987419200,964606362,267298207,874640231,737162446,244287424,201591011,444349662,857959050,124893179,245411527,97052765,597706248,417252287,10743102,71599057,391165276,627392448,823879391,373655345,243574162,523272294,408490460,556319349,719993443,825347009,204401978,295138954,677702213,20239399,766545764,959392597,8882529,201255090,731120953,92274050,136011803,263490283,276205036,67941595,756611788,594233624,466071694,69848693,527307949,885677534,738061104,293116251,180200252,8250261,191633200,549652841,992873709,109277412,578225045,230945923,37067897,704653436,435684364,612038658,274892591,112517944,285561628,605323188,9055376,123751248,415573547,662583641,869484360,656140608,453607164,432826203,20898455,379707979,55823716,999745208,295231177,169177693,105051778,766138877,423279513,405048006,271670055,390227034,860481089,431294990,731149180,198469309,841554897,639392071,159377394,682303551,998847664,848857678,226977531,844247880,876956878,76048700,883616287,353572460,223867403,849994313,674171452,793966819,573231328,741196702,203708803,651853056,709258364,198700531,862232931,376781931,546092802,850175256,631202598,596046558,853428010,730636173,499258518,927892160,905128249,633841296,861215457,26317959,412554593,317797959,832651441,173473709,759662281,403523288,618746605,809520304,890061387,778329498,120152632,181337659,95092837,81945903,19510167,653161736,278212841,832500871,604564712,211291582,872819903,235153443,630784738,843209392,103558096,388530250,416162213,564895611,795275106,132642745,303056239,594549986,536878966,798275473,425605837,630536971,417149073,325678695,572692723,516250725,376258800,232146029,212958666,325728319,229565453,600626807,631174692,634720296,536471324,965650190,683794461,591654605,786087560,881734293,254538704,38460646,179976723,52500969,937444136,755508838,561630106,280089688,558111165,736067311,710621393,374974132,254372532,448503654,174235474,370437724,273048354,117923950,567880840,458039845,32510802,568251368,520975033,69923153,307982697,395520595,630921265,490956133,260516038,652775187,225894979,861399044,209080084,854043149,69796341,167483757,598360776,956272531,930090779,180259195,708759413,866325149,13899809,919628783,546795614,210659116,793089379,158407975,260404184,703716972,629681953,136276179,430361253,970947627,790678379,504778287,819272119,950578700,448657676,84632939,246375697,715307886,858673440,400111746,955237498,649973442,85342493,956871270,32316334,228056183,298627309,702084336,370096295,595007988,341783769,892123135,703500489,400254558,283609527,20102883,352438997,474457481,853796263,518427752,74583874,261986306,567986155,720268807,669927285,184228964,244530852,854753414,980718318,354815199,158862468,124982130,223331607,143383250,32301482,587146814,996957457,934489731,480946637,246133231,95308204,148936227,348614734,691347610,190618243,510763441,347413852,441731792,244627167,357957970,918855014,249799937,976895523,667354119,822255341,975220497,768061379,254708594,219960259,667989751,504361459,413139714,286630321,610933232,979688424,859329810,145429729,5220008,597427878,963722436,984922066,291781603,755435061,20015660,195518545,643794426,94625667,311255859,329847363,760897847,393623666,40292639,406009239,681866273,520488780,951818396,516126653,655986303,989558425,152214462,656798363,507743987,656796412,270490988,95419691,421011146,361311011,255645483,78194487,8867262,215648433,768569339,692737295,525091232,290746971,12192341,421620039,981476518,947042809,587181792,728783873,120446484,924534674,992274936,342198607,562234937,86119190,765809894,129933501,830083596,438819991,768715772,977341153,60919978,633393144,795677061,491291866,255679716,471360489,567116082,842105435,747310201,860349775,861571904,363096322,769945415,285629458,568288915,180622156,437343415,193496349,169063173,694327853,11580711,567114696,571027414,717591348,267251281,669518523,248008451,795319117,559737354,685498414,14261725,336740207,880961446,485007814,82523316,891784523,482376807,423159023,715208765,968994303,568829410,447610610,186060911,234606494,74851435,894538413,191159378,748892083,695635791,491680764,263507980,210826629,46883493,620669983,784445023,913279779,240764108,747523976,664371237,51308705,40571493,696107586,887334980,864319230,923909327,132060656,110463015,32615643,637875045,216435229,546470618,887668256,849256999,783730161,116499184,673567690,924962056,918788132,907770534,744818690,985675303,304458294,350376344,276347671,890230976,718894469,996320149,769536326,799880440,178815158,840722624,888102,667804718,500577620,885475433,972272158,284797181,883507101,43355560,10781280,509648355,46726128,571779922,143138936,58899831,284207869,684806099,222134855,299707785,976602573,681843724,88009519,465643895,267372861,161913819,501220333,300268253,390591968,528863947,873542310,291224682,250046963,478137865,890039396,362908233,274052664,29649507,849727629,687480529,711592520,888552649,202618816,594007543,524347968,712534284,445234217,559853680,329710025,805039963,953999559,967977954,340564884,817953029,128442347,890501511,842637176,897535057,182363027,393611902,941002381,761113678,633407881,671698614,641081808,605413627,770812464,312776178,578732095,534865148,515789768,737099888,556730227,656597988,817698246,73559979,775160083,435607072,352438631,404127121,89216542,560696337,604199251,174193560,137144174,387152773,204080276,24300078,493019244,504070586,654064932,418788788,697843330,209846336,231180211,142662673,613757885,916162851,418494124,767629154,290618879,860335154,56772313,620172534,428466149,596001551,641548504,380193689,349713904,254317570,260425291,875973986,388504305,952896998,689178671,48656805,394855814,749863295,907632519,488169171,957007712,90897416,359722481,734582735,9228797,534748427,341832495,715377511,764677213,839806374,16610914,292966813,539675011,221101072,314466638,9953853,462575388,6423277,816981359,355631590,641172293,228097415,461217748,331948525,616719027,772246981,103936374,519921393,768339705,115394108,40829250,868559682,981340984,349926911,911984295,36046225,980128609,969867638,565035609,351422266,63109310,4923216,106865739,597845560,801481936,685398038,724782560,976079541,330208674,982040802,354579700,256394371,610468215,661586984,102964575,880152146,620223516,836903569,664702165,827998657,901250726,75351796,352708159,329570923,48647870,789522559,584972395,802841391,251237932,892963409,558173485,500019049,198292987,696729550,340747078,206576846,147000920,151320672,418412772,596630556,575977253,375269368,386964586,973457794,296912465,349538518,477068632,309676155,654742965,539779794,862961748,534788659,844912958,686290774,287126029,375999133,295449798,666412197,871807816,745394541,995121120,618797458,649624475,620337539,96253202,435852788,234845311,805453649,969711220,590412143,805106008,198589958,988029104,686363444,220658349,208195160,369746650,171921361,167063055,231014091,688630666,394872367,801636328,885430799,876183552,919711256,146455161,285116773,878810070,746696379,770405155,917485129,91314047,128759703,166168210,358759062,585480874,868697984,249133290,171910633,225727255,832106526,487017312,26429137,243314436,390263580,774848778,277702945,259590853,221370439,317165224,554100033,334821132,678166527,900015189,588002275,438340197,122089383,555618396,236407064,278933767,218056878,2130109,923647157,705279590,236724726,955628161,957818407,209553463,885067668,871882236,62703603,462426172,679603563,171176143,960333528,795929093,708420276,826043122,374333556,992600478,389955955,583903179,306928815,278443008,38833245,528843816,448363555,133555745,256300406,521787867,428174195,203262368,725759600,85309400,192192791,605921746,45557337,772411841,199432643,258954271,626790836,917038290,555178057,615157104,380599212,793873451,617705311,833703065,916884003,802612157,765442554,703112393,626187905,186932837,112456120,857009181,94578271,341898697,647337573,364893351,474248565,600897106,397865378,498348650,895889744,30359562,397111645,792564354,54688240,963476778,495197860,679656125,443690082,371270761,390741245,524047706,415899388,37606992,808784431,16378750,516688476,822579235,559185557,541080814,648580755,492142108,269045253,809704404,225455831,1266476,327500421,711067605,874314665,571267571,771371678,848521605,330000715,710614102,918588169,588968862,928383277,85464566,745226024,463024020,820089967,520573211,726460998,213442210,438253836,347129148,538464619,819202473,358733560,173805242,924494301,728323028,208947450,764232931,494918073,423044304,177807206,303916583,809247753,243879636,508378856,407455517,69507960,934565915,118564279,943654035,856787568,732880857,385615803,730130571,797378654,904328689,729375679,359184152,381897625,733732097,622857813,90265721,704711833,666457080,373945438,874267089,239218597,578734759,688626737,425273655,564556064,679237549,645498374,432424030,616340484,596975088,520884171,567476735,392707712,533292198,796908795,387048916,874917291,164960394,478740877,839033486,73819603,60514514,871304261,823152875,809197188,870875361,163630847,68940685,25810271,297014533,169294218,39809055,328102766,727419099,429631343,495731053,463492514,946353479,525634295,429858807,61356233,408059339,588752761,247936519,965015946,695008059,70082760,592120501,489676417,218052085,695973282,294424895,717588226,230045089,146145882,364440899,100123888,292595474,877623306,419170680,873004830,319806119,407808331,800232933,489354292,984714926,744302125,441818401,643618287,484845383,243509937,443645621,622187040,609433377,689048271,930851747,593927650,414874721,593121628,477656269,533448717,194507972,872486617,925718285,869866475,329610421,552439799,855006608,517531636,164737369,98796387,652589977,80413565,273807605,549265776,764607293,437701968,547201880,492291961,213557618,1527053,147804953,314561694,731615054,671495370,284677381,485303960,569723440,357942635,219435654,308390234,910022262,431034791,484051118,659087013,591373761,422013663,318844016,668185143,446212878,435926201,557684041,314627067,872116285,78951273,365182021,158565779,662529397,633995442,169864905,776119575,633872267,295928261,339908226,663969763,867820907,425854665,956470201,205757842,884736739,396335903,288101929,290649588,444302898,100157999,745415903,581378572,95679822,334734461,972038783,529322665,814501301,403337040,610776141,366435507,467129791,950225552,322532944,198473114,334499825,133270053,480219669,214411252,788789308,555579322,546206528,138178593,133656200,696253886,404393288,68603063,852170618,978486515,677162646,263489933,401919041,697876677,233498286,535796372,842101255,129100349,616390635,374071117,943828150,482265967,310659117,126019064,168029603,310175760,680451502,681874442,850784032,122938010,240556215,342476036,318190615,117913344,958988750,335826324,137309373,11644987,114856488,289435660,658839657,561453253,425986382,194841659,268323003,7525447,573228352,504720990,847121619,175680915,780729988,196824142,115892505,974089869,829141227,431914387,509123820,889596656,108610705,193130501,437754339,118544385,604476163,242103732,49192829,708828379,189201465,718645105,886515950,453699229,624274687,207654086,695720732,24841655,215857421,383195813,694541660,989111491,499547445,246604301,793452393,784155128,833253670,608171338,372619842,789536744,834705570,837876233,73499876,921442238,432986421,242766255,540122911,216659826,740899436,612028135,378482375,892092945,278475162,830182435,968249868,81298879,779689834,129424317,161440128,241122439,724852048,874969071,591002966,610211420,119638618,89333290,45669652,259227269,348997759,25913557,864709690,445756839,531913854,328905824,22259952,565436058,501249337,40856831,203784818,428051698,729079975,6874194,208830341,488739529,861367149,221052944,324261651,482342836,656865470,981740021,170164672,155584235,327257940,665579971,618533386,452570582,928895750,267598316,938601082,158991496,911397993,39763198,241265471,388919833,302937707,202319654,934840844,767391248,825733085,185722408,767641883,859055342,687897895,928966496,568662758,499076854,417120268,911137568,336988936,795077435,588062896,905263734,367905393,9580798,692561503,593542443,482225739,48604634,128193086,174279464,181403836,923704181,997806339,824519310,434221049,110558302,206468480,327967820,542114820,336962222,214473652,266493420,542513662,426896115,967013536,765456765,980340722,104823906,187636256,718697267,760339432,390172982,765469217,564502255,493419803,168319314,939953586,480692216,739370327,801907057,311781133,259852937,347955628,907499243,977827281,741881869,768942703,709196892,478502471,138927474,470626938,977129403,426871045,387960758,769978957,768476164,673521295,374129072,451707360,44505916,190848306,15751779,396972807,738136536,108205051,745220926,978072052,445810474,153584174,696497940,405949132,162746936,121825690,441448616,405950845,617680410,874846267,418502271,52613517,95495759,567948277,21203456,123628693,794324842,588467263,712112404,467405148,354191339,168442875,957292332,606168253,457326302,796741303,813416926,903575679,239654114,874216432,744639644,785031526,214412191,942008608,510280468,172528922,470230820,530386912,137043338,322765056,844265896,584003957,663537568,653196908,454758359,387148003,224141866,452445990,73298319,667767518,937818749,204133848,887742616,437320824,650799972,726656620,771087718,755200155,872385232,597144696,406311936,636395756,812180694,849613194,697704603,422919385,498226637,715167151,718605889,825432280,985029647,94534410,233056302,960003533,313450259,426905104,55303247,468977944,606551042,58072430,390400210,870765937,194527776,387034846,261988487,742698643,85346489,175449206,633175523,733088772,497583355,519079716,797076684,955534232,289448347,167809093,483746162,930606406,164093095,745410158,633325768,850659183,255075008,830684561,690254674,354047433,577909920,568818524,720151833,120119134,711060617,718163480,441465242,196752359,490440231,837227608,808001152,644200732,306898710,740332086,226424482,377666771,201771510,195183066,581740608,972384101,482045830,719003199,205694076,534850261,321826519,555665086,780261138,610678134,16331747,462704237,216019263,313073344,293274297,677235657,392046975,169206307,151695985,213644854,838570367,377376309,560039099,262663474,245354918,588137420,710612005,361825442,558400509,631750564,265573236,928356689,548552220,994571714,658305666,492195436,884222305,89592902,380649880,956920060,125489295,264661072,701530305,950785462,319345052,982970924,68614762,369607771,492280294,903336594,45367322,913944840,241258937,496624184,364097149,997430725,359931918,985609635,224211397,428861923,455906380,356391411,22125965,895728204,816392427,83595716,573790083,451380027,407619382,726832060,76874445,47770250,532495946,778106981,331685201,794399920,883118076,811577597,578469873,645811550,90215584,457729828,789301861,100882948,353447633,183146397,639408951,53035901,184407609,143150744,452722846,588641356,185106150,28604791,562734633,628404658,936793986,707072984,42473776,306344156,944630691,69209668,60756828,68321348,813937160,771909654,8365404,172520260,549285416,237237382,432965264,218483178,156721737,928523320,146844224,209105083,986585384,975801972,750869511,282723114,383679142,470988194};

int random() {
    static int i = 0;
    i++;
    return random_numbers[i];
}


/* Set to 1 to test maze generation routines. */
#define TEST_MAZE_GEN 0


/* Set to 1 to remove all walls as a debugging aid. (Nate Taylor, S07). */
#define GOD_MODE 0


/* local functions--see function headers for details */
static int mark_maze_area (int x, int y);
static void add_a_fruit_internal ();
#if (TEST_MAZE_GEN == 0) /* not used when testing maze generation */
static unsigned char* find_block (int x, int y);
static void _add_a_fruit (int show);
#endif


/*
 * The maze array contains a one byte bit vector (maze_bit_t) for each
 * location in a maze.  The left and right boundaries of the maze are unified,
 * i.e., column 0 also forms the right boundary via wraparound.  Drawings
 * for each block in the maze are chosen based on a five-point stencil
 * that includes north, east, south, and west neighbor blocks.  For
 * simplicity, the maze array is extended with additional rows on the top
 * and bottom to avoid boundary conditions.
 *
 * Under these assumptions, the upper left boundary of the maze is at (0,1),
 * and the lower right boundary is at (2 X_DIM, 2 Y_DIM + 1).  The stencil
 * calculation for the lower right boundary includes the point below it,
 * which is (2 X_DIM, 2 Y_DIM + 2).  As the width of the maze is 2 X_DIM,
 * the index of this point is 2 X_DIM + (2 Y_DIM + 2) * 2 X_DIM, or
 * 2 X_DIM (2 Y_DIM + 3), and the space allocated is one larger than this
 * maximum index value.
 */
static unsigned char maze[2 * MAZE_MAX_X_DIM * (2 * MAZE_MAX_Y_DIM + 3) + 1];
static int maze_x_dim;          /* horizontal dimension of maze */
static int maze_y_dim;          /* vertical dimension of maze   */
static int n_fruits;          /* number of fruits in maze     */
static int exit_x, exit_y;    /* lattice point of maze exit   */

int get_fruits(){
    return n_fruits;
}


/*
 * maze array index calculation macro; maze dimensions are valid only
 * after a call to make_maze
 */
#define MAZE_INDEX(a,b) ((a) + ((b) + 1) * maze_x_dim * 2)


/*
 * mark_maze_area
 *   DESCRIPTION: Uses a breadth-first search to marks all parts of the
 *                maze accessible from (x,y) with the MAZE_REACH bit.
 *                Stops at walls and at maze locations already marked
 *                as reached.
 *   INPUTS: (x,y) -- starting coordinate within maze
 *   OUTPUTS: none
 *   RETURN VALUE: number of maze locations marked
 *   SIDE EFFECTS: leaves MAZE_REACH markers on marked portion of maze
 */
static int
mark_maze_area (int x, int y)
{
    /*
     * queue for breadth-first search
     *
     * The queue holds pointers to maze locations in memory.  It is
     * large enough to hold the whole maze, although it should never
     * hold more than twice the minimum of rows and columns at any
     * time with our maze graphs.
     *
     * q_start is the index of the first unexplored location in the queue
     * q_end is the index just after the last unexplored location in the
     *       queue
     * cur is the maze location being explored
     */
    unsigned char* q[MAZE_MAX_X_DIM * MAZE_MAX_Y_DIM];
    int q_start, q_end;
    unsigned char* cur;

    /* Mark the starting location as reached, then put it into the queue. */
    q[0] = &maze[MAZE_INDEX (x, y)];
    *(q[0]) |= MAZE_REACH;
    q_start = 0;
    q_end = 1;

    /* Loop until queue is empty. */
    while (q_start != q_end) {

        /* Get location from front of queue. */
        cur = q[q_start++];

        /*
         * Explore four directions from current position.  Maze
         * construction guarantees that an adjacent open space implies
         * that the subsequent space in the same direction both exists
         * and is open (not a MAZE_WALL).
         *
         * Newly found locations are marked as reached before being
         * added to the queue, which prevents the same location from
         * being added when reached by multiple paths of equal length
         * from the starting point.
         */
        if ((cur[-2 * maze_x_dim] & MAZE_WALL) == 0 &&
            (cur[-4 * maze_x_dim] & MAZE_REACH) == 0) {
            cur[-4 * maze_x_dim] |= MAZE_REACH;
            q[q_end++] = &cur[-4 * maze_x_dim];
        }
        if ((cur[1] & MAZE_WALL) == 0 &&
            (cur[2] & MAZE_REACH) == 0) {
            cur[2] |= MAZE_REACH;
            q[q_end++] = &cur[2];
        }
        if ((cur[2 * maze_x_dim] & MAZE_WALL) == 0 &&
            (cur[4 * maze_x_dim] & MAZE_REACH) == 0) {
            cur[4 * maze_x_dim] |= MAZE_REACH;
            q[q_end++] = &cur[4 * maze_x_dim];
        }
        if ((cur[-1] & MAZE_WALL) == 0 &&
            (cur[-2] & MAZE_REACH) == 0) {
            cur[-2] |= MAZE_REACH;
            q[q_end++] = &cur[-2];
        }
    }

    /*
     * The queue is empty.  The number of locations marked is just q_end,
     * the number that passed through the queue.
     */
    return q_end;
}


/*
 * make_maze
 *   DESCRIPTION: Create a maze of specified dimensions.  The maze is
 *                built as a two-dimensional lattice in which the points
 *       01234      with odd indices in both dimensions are always open,
 *     0 -----      those with even indices in both dimensions are always
 *     1 - ? -      walls, and other points are either open or walls to form
 *     2 -?*?-      the maze.  The maze to the left is a 2x2 example.  The
 *     3 - ? -      spaces are the four (odd,odd) lattice points.  The
 *     4 -----      boundary is marked with minus signs (these are always
 *            walls).  The one (even,even) lattice point--also always
 *            a wall--is marked with an asterisk.  Finally, the
 *            four question marks may or may not be walls; these
 *            four options are used to create different mazes.
 *
 *                The algorithm used consists of two phases.  In the first
 *                phase, metaphorical worms are dropped into the maze and
 *                allowed to wander about randomly, digging out the maze,
 *                until they decide to stop.  More worms are added until
 *                all of the (odd,odd) points have been cleared.  Each worm
 *              starts on an (odd,odd) point still marked as a wall.
 *
 *                Once the worms have done their work, the second phase
 *                of the algorithm begins.  This phase ensures that a path
 *                exists from any (odd,odd) lattice point to any other
 *                (odd,odd) point.  First, those points connected to the
 *                point (1,1) are marked as reachable.  Next, an unconnected
 *                point adjacent to a connected point is chosen at random,
 *                and the wall between them is removed, making another
 *                section of the maze reachable from (1,1).  This process
 *                continues until most of the maze is reachable or a
 *                certain number of attempts have been made, at which point
 *                we scan the maze for such adjacent pairs (rather than
 *                choosing randomly) until the entire maze is reachable
 *                from (1,1).
 *   INPUTS: (x_dim,y_dim) -- size of maze
 *           start_fruits -- number of fruits to place in maze
 *   OUTPUTS: none
 *   RETURN VALUE: 0 on success, -1 on failure (if requested maze size
 *              exceeds limits set by defined values, with minimum
 *              (MAZE_MIN_X_DIM,MAZE_MIN_Y_DIM) and maximum
 *              (MAZE_MAX_X_DIM,MAZE_MAX_Y_DIM))
 *   SIDE EFFECTS: leaves MAZE_REACH markers on marked portion of maze
 */
int
make_maze (int x_dim, int y_dim, int start_fruits)
{
    /*
     * worm turn weights; the first dimension is relative direction
     * (number of 90-degree turns clockwise from up); the second is
     * whether the resulting space is open (not a wall) or a wall.
     */
    static int turn_wt[4][2] = {{1, 84}, {1, 9}, {3, 3}, {1, 9}};

    int remaining, trials;
    int x, y, wt[4], pick, dir, pref_dir, total, i;
    unsigned char* cur;

    /* Check the requested size, and save in local state if it is valid. */
    if (x_dim < MAZE_MIN_X_DIM || x_dim > MAZE_MAX_X_DIM ||
        y_dim < MAZE_MIN_Y_DIM || y_dim > MAZE_MAX_Y_DIM)
        return -1;
    maze_x_dim = x_dim;
    maze_y_dim = y_dim;

    /* Fill the maze with walls. */
    memset (maze, MAZE_WALL, sizeof (maze));

    /* Seed the random number generator. */
    /* srandom (time (NULL)); */

    /*
     * 'worm' phase of maze generation
     */

    /*
     * Track the number of (odd,odd) lattice points still marked
     * as MAZE_WALL.
     */
    remaining = maze_x_dim * maze_y_dim;
    do {
        /* Pick an (odd,odd) lattice point still marked as a MAZE_WALL. */
        do {
            x = (random () % maze_x_dim) * 2 + 1;
            y = (random () % maze_y_dim) * 2 + 1;
        } while ((maze[MAZE_INDEX (x, y)] & MAZE_WALL) == 0);

        /* Empty the starting point. */
        maze[MAZE_INDEX (x, y)] = MAZE_NONE;
        remaining--;

        /* The worm's initial preferred direction is random. */
        pref_dir = (random () % 4);

        /* Move around the maze until worm turns back on itself. */
        while (1) {
            /*
             * Choose the next direction of motion using weighted random
             * selection.  The directions are hardcoded.  The wt array
             * is the cumulative weight for each direction, and total
             * holds the running total weight (==wt[3] at the end).
             * A random value from 0 to total-1 is then chosen, and the
             * direction picked according to the weight distribution.
             * Weighting depends on direction and whether or not the
             * maze location has already been visited (is not a MAZE_WALL).
             * This code
             */
            total = 0;
            if (y > 1)
                total += turn_wt[pref_dir]
                    [maze[MAZE_INDEX (x, y - 2)] == MAZE_WALL];
            wt[0] = total;
            if (x < maze_x_dim * 2 - 1)
                total += turn_wt[(pref_dir + 3) % 4]
                    [maze[MAZE_INDEX (x + 2, y)] == MAZE_WALL];
            wt[1] = total;
            if (y < maze_y_dim * 2 - 1)
                total += turn_wt[(pref_dir + 2) % 4]
                    [maze[MAZE_INDEX (x, y + 2)] == MAZE_WALL];
            wt[2] = total;
            if (x > 1)
                total += turn_wt[(pref_dir + 1) % 4]
                    [maze[MAZE_INDEX (x - 2, y)] == MAZE_WALL];
            wt[3] = total;
            pick = (random () % total);
            for (dir = 0; pick >= wt[dir]; dir++);

            /* If worm decides to turn around, it's done. */
            if (((dir - pref_dir + 4) % 4) == 2)
                break;

            /* Move one space in the preferred direction. */
            pref_dir = dir;
            switch (pref_dir) {
            case 0:
                maze[MAZE_INDEX (x, y - 1)] = MAZE_NONE;
                y -=2;
                break;
            case 1:
                maze[MAZE_INDEX (x + 1, y)] = MAZE_NONE;
                x += 2;
                break;
            case 2:
                maze[MAZE_INDEX (x, y + 1)] = MAZE_NONE;
                y +=2;
                break;
            case 3:
                maze[MAZE_INDEX (x - 1, y)] = MAZE_NONE;
                x -= 2;
                break;
            }

            /* If necessary, the worm 'eats' the wall at the new space. */
            if (maze[MAZE_INDEX (x, y)] == MAZE_WALL)
                remaining--;
            maze[MAZE_INDEX (x, y)] = MAZE_NONE;
        } /* loop for one worm */

        /*
         * The worm phase continues until all of the (odd,odd) lattice
         * points in the maze are all empty.
         */
    } while (remaining > 0);

    /*
     * Begin the second phase of the algorithm, in which we guarantee
     * connectivity between all (odd,odd) lattice points in the maze.
     * We start by marking everything connected to (1,1).
     */
    remaining = maze_x_dim * maze_y_dim - mark_maze_area (1, 1);
    trials = 0;
    do {
        /*
         * Once most of the maze is connected, or we have tried randomly
         * "enough" times (arbitrarily defined as 100 times here, we scan
         * the rest of the maze for opportunities for connecting new regions
         * of the maze to the (1,1) lattice point.
         */
        if (remaining < 20 || ++trials > 100) {
            if ((x += 2) > maze_x_dim * 2) {
                x -= maze_x_dim * 2;
                if ((y += 2) > 2 * maze_y_dim)
                    y -= 2 * maze_y_dim;
            }
            cur = &maze[MAZE_INDEX (x, y)];
            if ((cur[0] & MAZE_REACH) != 0)
                continue;
        } else {
            /* Pick an unconnected (odd,odd) lattice point at random. */
            do {
                x = (random () % maze_x_dim) * 2 + 1;
                y = (random () % maze_y_dim) * 2 + 1;
                cur = &maze[MAZE_INDEX (x, y)];
            } while ((cur[0] & MAZE_REACH) != 0);
        }
        /*
         * Try to connect the unconnected point by knocking down a wall
         * in some direction.
         */
        if (y > 1 && (cur[-4 * maze_x_dim] & MAZE_REACH) != 0)
            cur[-2 * maze_x_dim] = MAZE_NONE;
        else if (x > 1 && (cur[-2] & MAZE_REACH) != 0)
            cur[-1] = MAZE_NONE;
        else if (x < 2 * maze_x_dim - 1 && (cur[2] & MAZE_REACH) != 0)
            cur[1] = MAZE_NONE;
        else if (y < 2 * maze_y_dim - 1 &&
                 (cur[4 * maze_x_dim] & MAZE_REACH) != 0)
            cur[2 * maze_x_dim] = MAZE_NONE;
        else
            continue;
        /*
         * Success!  Mark the newly connected portion of the maze
         * as reachable.
         */
        remaining -= mark_maze_area (x, y);
    } while (remaining > 0);

    /*
     * Remove the MAZE_REACH markers--these are reused to mark those
     * portions of the maze already seen by the player.
     */
    for (x = 1; x < 2 * maze_x_dim; x += 2)
        for (y = 1; y < 2 * maze_y_dim; y += 2)
            maze[MAZE_INDEX (x, y)] &= ~MAZE_REACH;

#if 0 /* Be kind and show the maze boundary at start. */
    for (x = 0; x < 2 * maze_x_dim; x++) {
        maze[MAZE_INDEX (x, 0)] |= MAZE_REACH;
        maze[MAZE_INDEX (x, 2 * maze_y_dim)] |= MAZE_REACH;
    }
    /* The value at y == 2 * maze_y_dim is the bottom of the right boundary. */
    for (y = 0; y <= 2 * maze_y_dim + 1; y++)
        maze[MAZE_INDEX (0, y)] |= MAZE_REACH;
#endif

#if GOD_MODE /* Remove all walls! */
    for (x = 1; x < 2 * maze_x_dim; x++) {
        for (y = 1; y < 2 * maze_y_dim; y++) {
            maze[MAZE_INDEX (x, y)] = MAZE_NONE;
        }
    }
#endif

    /* Put the required number of fruits in the maze. */
    n_fruits = 0;
    for (i = 0; i < start_fruits; i++)
        add_a_fruit_internal ();

    /* Find an unfruited maze point and put the maze exit there. */
    do {
        x = (random () % maze_x_dim) * 2 + 1;
        y = (random () % maze_y_dim) * 2 + 1;
    } while ((maze[MAZE_INDEX (x, y)] & MAZE_FRUIT));
    maze[MAZE_INDEX (x, y)] |= MAZE_EXIT;
    exit_x = x;
    exit_y = y;

    return 0;
}

/*
 * The functions inside the preprocessor block below rely on block image
 * data in blocks.s.  These external data are neither available nor
 * necessary for testing maze generation, and are omitted to simplify
 * linking the test program (i.e., when TEST_MAZE_GEN is 1).
 */
#if (TEST_MAZE_GEN == 0)


/*
 * find_block
 *   DESCRIPTION: Find the appropriate image to be used for a given maze
 *                lattice point.
 *   INPUTS: (x,y) -- the maze lattice point
 *   OUTPUTS: none
 *   RETURN VALUE: a pointer to an image of a BLOCK_X_DIM x BLOCK_Y_DIM
 *                 block of data with one byte per pixel laid out as a
 *                 C array of dimension [BLOCK_Y_DIM][BLOCK_X_DIM]
 *   SIDE EFFECTS: none
 */
static unsigned char*
find_block (int x, int y)
{
    int fnum;     /* fruit found                           */
    int pattern;  /* stencil pattern for surrounding walls */

    /* Record whether fruit is present. */
    fnum = (maze[MAZE_INDEX (x, y)] & MAZE_FRUIT) / MAZE_FRUIT_1;

    /* The exit is always visible once the last fruit is collected. */
    if (n_fruits == 0 && (maze[MAZE_INDEX (x, y)] & MAZE_EXIT) != 0)
        return (unsigned char*)blocks[BLOCK_EXIT];

    /*
     * Everything else not reached is shrouded in mist, although fruits
     * show up as bumps.
     */
    if ((maze[MAZE_INDEX (x, y)] & MAZE_REACH) == 0) {
        if (fnum != 0)
            return (unsigned char*)blocks[BLOCK_FRUIT_SHADOW];
        return (unsigned char*)blocks[BLOCK_SHADOW];
    }

    /* Show fruit. */
    if (fnum != 0)
        return (unsigned char*)blocks[BLOCK_FRUIT_1 + fnum - 1];

    /* Show empty space. */
    if ((maze[MAZE_INDEX (x, y)] & MAZE_WALL) == 0)
        return (unsigned char*)blocks[BLOCK_EMPTY];

    /* Show different types of walls. */
    pattern = (((maze[MAZE_INDEX (x, y - 1)] & MAZE_WALL) != 0) << 0) |
        (((maze[MAZE_INDEX (x + 1, y)] & MAZE_WALL) != 0) << 1) |
        (((maze[MAZE_INDEX (x, y + 1)] & MAZE_WALL) != 0) << 2) |
        (((maze[MAZE_INDEX (x - 1, y)] & MAZE_WALL) != 0) << 3);
    return (unsigned char*)blocks[pattern];
}


/*
 * fill_horiz_buffer
 *   DESCRIPTION: Given the (x,y) map pixel coordinate of the leftmost
 *                pixel of a line to be drawn on the screen, this routine
 *                produces an image of the line.  Each pixel on the line
 *                is represented as a single byte in the image.
 *   INPUTS: (x,y) -- leftmost pixel of line to be drawn
 *   OUTPUTS: buf -- buffer holding image data for the line
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
void
fill_horiz_buffer (int x, int y, unsigned char buf[SCROLL_X_DIM])
{
    int map_x, map_y;     /* maze lattice point of the first block on line */
    int sub_x, sub_y;     /* sub-block address                             */
    int idx;              /* loop index over pixels in the line            */
    unsigned char* block; /* pointer to current maze block image           */

    /* Find the maze lattice point and the pixel address within that block. */
    map_x = x / BLOCK_X_DIM;
    map_y = y / BLOCK_Y_DIM;
    sub_x = x - map_x * BLOCK_X_DIM;
    sub_y = y - map_y * BLOCK_Y_DIM;

    /* Loop over pixels in line. */
    for (idx = 0; idx < SCROLL_X_DIM; ) {

        /* Find address of block to be drawn. */
        block = find_block (map_x++, map_y) + sub_y * BLOCK_X_DIM + sub_x;

        /* Write block colors from one line into buffer. */
        for (; idx < SCROLL_X_DIM && sub_x < BLOCK_X_DIM; idx++, sub_x++)
            buf[idx] = *block++;

        /*
         * All subsequent blocks are copied starting from the left side
         * of the block.
         */
        sub_x = 0;
    }
}

/*
 * fill_vert_buffer
 *   DESCRIPTION: Given the (x,y) map pixel coordinate of the top pixel of
 *                a vertical line to be drawn on the screen, this routine
 *                produces an image of the line.  Each pixel on the line
 *                is represented as a single byte in the image.
 *   INPUTS: (x,y) -- top pixel of line to be drawn
 *   OUTPUTS: buf -- buffer holding image data for the line
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
void
fill_vert_buffer (int x, int y, unsigned char buf[SCROLL_Y_DIM])
{
    int map_x, map_y;     /* maze lattice point of the first block on line */
    int sub_x, sub_y;     /* sub-block address                             */
    int idx;              /* loop index over pixels in the line            */
    unsigned char* block; /* pointer to current maze block image           */

    /* Find the maze lattice point and the pixel address within that block. */
    map_x = x / BLOCK_X_DIM;
    map_y = y / BLOCK_Y_DIM;
    sub_x = x - map_x * BLOCK_X_DIM;
    sub_y = y - map_y * BLOCK_Y_DIM;

    /* Loop over pixels in line. */
    for (idx = 0; idx < SCROLL_Y_DIM; ) {

        /* Find address of block to be drawn. */
        block = find_block (map_x, map_y++) + sub_y * BLOCK_X_DIM + sub_x;

        /* Write block colors from one line into buffer. */
        for (; idx < SCROLL_Y_DIM && sub_y < BLOCK_Y_DIM;
             idx++, sub_y++, block += BLOCK_X_DIM)
            buf[idx] = *block;

        /*
         * All subsequent blocks are copied starting from the top
         * of the block.
         */
        sub_y = 0;
    }

    return;
}


/*
 * unveil_space
 *   DESCRIPTION: Unveils a maze lattice point (marks as MAZE_REACH, which
 *                means that it is drawn normally rather than as under mist),
 *                redrawing it if necessary.
 *   INPUTS: (x,y) -- the lattice point to be unveiled
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: may draw to the screen
 */
void
unveil_space (int x, int y)
{
    unsigned char* cur; /* pointer to the maze lattice point */

    /*
     * There's a wee bitty little bug in this function in the sense
     * that, if the left boundary is exposed, and the player reaches
     * the right boundary without scrolling the screen, the right
     * boundary will not be redrawn, and will appear to remain obscured.
     * One fix is to draw both left and right boundaries when unveiling
     * a left/right boundary block.  But it doesn't matter much, since
     * left and right boundaries aren't on the screen at the same time
     * anyway for our mazes.
     */

    /*
     * Allow exposure of bottom and right boundaries (left and right
     * boundaries are the same lattice point in the maze).
     */
    if (x < 0 || x > 2 * maze_x_dim || y < 0 || y > 2 * maze_y_dim)
        return;

    /* Has the location already been seen?  If so, do nothing. */
    cur = &maze[MAZE_INDEX (x, y)];
    if (*cur & MAZE_REACH)
        return;

    /* Unveil the location and redraw it. */
    *cur |= MAZE_REACH;
    draw_full_block (x * BLOCK_X_DIM, y * BLOCK_Y_DIM, find_block (x, y));
}


/*
 * check_for_fruit
 *   DESCRIPTION: Checks a maze lattice point for fruit, eats the fruit if
 *                one is present (i.e., removes it from the maze), and updates
 *                the number of fruits (including displayed number).
 *   INPUTS: (x,y) -- the lattice point to be checked for fruit
 *   OUTPUTS: none
 *   RETURN VALUE: fruit number found (1 to NUM_FRUITS), or 0 for no fruit
 *   SIDE EFFECTS: may draw to the screen (empty fruit and, once last fruit
 *                 is eaten, the maze exit)
 */
int
check_for_fruit (int x, int y)
{
    int fnum;  /* fruit number found */

    /* If outside the feasible fruit range, return no fruit. */
    if (x < 0 || x >= 2 * maze_x_dim || y < 0 || y >= 2 * maze_y_dim)
        return 0;

    /* Calculate the fruit number. */
    fnum = (maze[MAZE_INDEX (x, y)] & MAZE_FRUIT) / MAZE_FRUIT_1;

    /* If fruit was present... */
    if (fnum != 0) {
        /* ...remove it. */
        maze[MAZE_INDEX (x, y)] &= ~MAZE_FRUIT;

        /* Update the count of fruits. */
        --n_fruits;

        /* The exit may appear. */
        if (n_fruits == 0)
            draw_full_block (exit_x * BLOCK_X_DIM, exit_y * BLOCK_Y_DIM,

                             find_block (exit_x, exit_y));

        /* Redraw the space with no fruit. */
        draw_full_block (x * BLOCK_X_DIM, y * BLOCK_Y_DIM,
                         find_block (x, y));
    }

    /* Return the fruit number found. */
    return fnum;
}


/*
 * check_for_win
 *   DESCRIPTION: Checks whether the play has won the maze by reaching a
 *                given maze lattice point.  Winning occurs when no fruits
 *                remain in the maze, and the player reaches the maze exit.
 *   INPUTS: (x,y) -- the lattice point at which the player has arrived
 *   OUTPUTS: none
 *   RETURN VALUE: 1 if player has won, 0 if not
 *   SIDE EFFECTS: none
 */
int
check_for_win (int x, int y)
{
    /* Check that position falls within valid boundaries for exit. */
    if (x < 0 || x >= 2 * maze_x_dim || y < 0 || y >= 2 * maze_y_dim)
        return 0;

    /* Return win condition. */
    return (n_fruits == 0 && (maze[MAZE_INDEX (x, y)] & MAZE_EXIT) != 0);
}


/*
 * _add_a_fruit
 *   DESCRIPTION: Add a fruit to a random (odd,odd) lattice point in the
 *                maze.  Update the number of fruits, including the displayed
 *                value.  If requested, draw the new fruit on the screen.
 *   INPUTS: show -- 1 if new fruit should be drawn, 0 if not
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: changes displayed fruit value, may draw to screen
 */
static void
_add_a_fruit (int show)
{
    int x, y;    /* lattice point for new fruit */

    /*
     * Pick an unfruited lattice point at random.  Could fall on the
     * maze exit, if that is already defined.
     */
    do {
        x = (random () % maze_x_dim) * 2 + 1;
        y = (random () % maze_y_dim) * 2 + 1;
    } while ((maze[MAZE_INDEX (x, y)] & MAZE_FRUIT));

    /* Add a random fruit to that location. */
    maze[MAZE_INDEX (x, y)] |=
        ((random () % NUM_FRUIT_TYPES) + 1) * MAZE_FRUIT_1;

    /* Update the number of fruits. */
    ++n_fruits;

    /* If necessary, draw the fruit on the screen. */
    if (show)
        draw_full_block (x * BLOCK_X_DIM, y * BLOCK_Y_DIM,
                         find_block (x, y));
}


/*
 * add_a_fruit
 *   DESCRIPTION: Add a fruit to a random (odd,odd) lattice point in the
 *                maze.  Update the number of fruits, including the displayed
 *                value.  Draw the new fruit on the screen.  If the new fruit
 *                is the only one in the maze, erase the maze exit.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: the number of fruits in the maze (after addition)
 *   SIDE EFFECTS: changes displayed fruit value, may draw to screen
 */
int
add_a_fruit ()
{
    /* Most of the work is done by a helper function. */
    _add_a_fruit (1);

    /* The exit may disappear. */
    if (n_fruits == 1)
        draw_full_block (exit_x * BLOCK_X_DIM, exit_y * BLOCK_Y_DIM,

                         find_block (exit_x, exit_y));

    /* Return the current number of fruits in the maze. */
    return n_fruits;
}


/*
 * add_a_fruit_internal
 *   DESCRIPTION: Add a fruit to a random (odd,odd) lattice point in the
 *                maze.  Update the number of fruits, including the displayed
 *                value.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: changes displayed fruit value
 */
static void
add_a_fruit_internal ()
{
    /*
     * Call a helper function, indicating that fruit should not be drawn
     * on the screen at this point.
     */
    _add_a_fruit (0);
}


/*
 * get_player_block
 *   DESCRIPTION: Get a graphical image for the player.
 *   INPUTS: cur_dir -- current direction of motion for the player
 *   OUTPUTS: none
 *   RETURN VALUE: a pointer to an image of a BLOCK_X_DIM x BLOCK_Y_DIM
 *                 block of data with one byte per pixel laid out as a
 *                 C array of dimension [BLOCK_Y_DIM][BLOCK_X_DIM]
 *   SIDE EFFECTS: none
 */
unsigned char*
get_player_block (dir_t cur_dir)
{
    return (unsigned char*)blocks[BLOCK_PLAYER_UP + cur_dir];
}


/*
 * get_player_mask
 *   DESCRIPTION: Get a graphical mask for the player.
 *   INPUTS: cur_dir -- current direction of motion for the player
 *   OUTPUTS: none
 *   RETURN VALUE: a pointer to an image of a BLOCK_X_DIM x BLOCK_Y_DIM
 *                 block of data with one byte per pixel laid out as a
 *                 C array of dimension [BLOCK_Y_DIM][BLOCK_X_DIM];
 *                 the bytes in this block indicate whether or not the
 *                 corresponding byte in the player image should be
 *                 drawn (1 is drawn/opaque, 0 is not drawn/fully
 *                 transparent)
 *   SIDE EFFECTS: none
 */
unsigned char*
get_player_mask (dir_t cur_dir)
{
    return (unsigned char*)blocks[BLOCK_PLAYER_MASK_UP + cur_dir];
}


/*
 * find_open_directions
 *   DESCRIPTION: Determine which directions are open to movement from a
 *              given maze point.
 *   INPUTS: (x,y) -- lattice point of interest in maze
 *   OUTPUTS: open[] -- array of boolean values indicating that a direction
 *                   is open; indexed by DIR_* enumeration values
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
void
find_open_directions (int x, int y, int op[NUM_DIRS])
{
    op[DIR_UP]    = (0 == (maze[MAZE_INDEX (x, y - 1)] & MAZE_WALL));
    op[DIR_RIGHT] = (0 == (maze[MAZE_INDEX (x + 1, y)] & MAZE_WALL));
    op[DIR_DOWN]  = (0 == (maze[MAZE_INDEX (x, y + 1)] & MAZE_WALL));
    op[DIR_LEFT]  = (0 == (maze[MAZE_INDEX (x - 1, y)] & MAZE_WALL));
}


#else /* TEST_MAZE_GEN == 1 */
/*
 * The code here allows you to test the maze generation routines visually
 * by creating a maze and printing it to the screen.
 */


/*
 * print_maze
 *   DESCRIPTION: Print a maze as ASCII text.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: prints to stdout
 */
void
print_maze ()
{
    int i;  /* vertical loop index   */
    int j;  /* horizontal loop index */

    /* Loop over maze rows. */
    for (i = 0; i <= 2 * maze_y_dim; i++) {

        /* Loop over maze columns. */
        for (j = 0; j <= 2 * maze_x_dim; j++) {

            /*
             * Print open spaces and walls, reached and unreached, as
             * distinct characters.
             */
            printf ("%c",
                    ((maze[MAZE_INDEX (j, i)] & MAZE_WALL) ?
                     ((maze[MAZE_INDEX (j, i)] & MAZE_REACH) ? '*' : '%') :
                     ((maze[MAZE_INDEX (j, i)] & MAZE_REACH) ? '.' : ' ')));
        }

        /* End the printed line. */
        puts ("");
    }
}


/*
 * This function is called in maze generation.  We define a stub to keep
 * the linker happy.
 */
static void add_a_fruit_internal () {}


/*
 * main
 *   DESCRIPTION: main program for testing maze generation; hardwired to
 *                build and print a maze of a certain size
 *   INPUTS: none (command line arguments are ignored)
 *   OUTPUTS: none
 *   RETURN VALUE: 0 on success (always!)
 */
int
main ()
{
    make_maze (20, 20, 0);
    print_maze ();
    return 0;
}

#endif /* TEST_MAZE_GEN */
